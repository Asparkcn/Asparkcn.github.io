<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySql 命令合集</title>
      <link href="/posts/2.html"/>
      <url>/posts/2.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-ddl"><a class="markdownIt-Anchor" href="#一-ddl"></a> 一、 DDL</h1><h2 id="1-数据库操作"><a class="markdownIt-Anchor" href="#1-数据库操作"></a> 1. 数据库操作</h2><h3 id="1查询"><a class="markdownIt-Anchor" href="#1查询"></a> （1）查询</h3><ul><li><p>查询所有数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure></li><li><p>查询当前数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select database();</span><br></pre></td></tr></table></figure></li></ul><h3 id="2创建"><a class="markdownIt-Anchor" href="#2创建"></a> （2）创建</h3><ul><li><p>创建数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database [if not exists] 数据库名 [default charset 字符集] [collate 排序规则];</span><br></pre></td></tr></table></figure></li></ul><h3 id="3删除"><a class="markdownIt-Anchor" href="#3删除"></a> （3）删除</h3><ul><li><p>删除数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database [if exists] 数据库名</span><br></pre></td></tr></table></figure></li></ul><h3 id="4使用"><a class="markdownIt-Anchor" href="#4使用"></a> （4）使用</h3><ul><li><p>使用数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-表操作"><a class="markdownIt-Anchor" href="#2-表操作"></a> 2. 表操作</h2><h3 id="1查询-show-desc"><a class="markdownIt-Anchor" href="#1查询-show-desc"></a> （1）查询 <code>show</code> | <code>desc</code></h3><ul><li><p>查询当前数据库所有表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure></li><li><p>查询表结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">desc 表名; </span><br><span class="line">describe 表名;</span><br><span class="line">show columns from 表名;</span><br></pre></td></tr></table></figure></li><li><p>查询指定表的建表语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create table 表名;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2创建-create-table-create-index"><a class="markdownIt-Anchor" href="#2创建-create-table-create-index"></a> （2）创建 <code>create table</code> | <code>create index</code></h3><ul><li><p>建表语句</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table 表名 (列名1 数据类型 [约束] [comment 注释], 列名2 数据类型 [约束] [comment 注释], ...);</span><br></pre></td></tr></table></figure></li><li><p>创建索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create [unique|fulltext|spatial] index 索引名称 on 表名(字段名称[(长度)] [asc|desc])</span><br></pre></td></tr></table></figure></li></ul><h3 id="3修改-alter-table"><a class="markdownIt-Anchor" href="#3修改-alter-table"></a> （3）修改 <code>alter table</code></h3><ul><li><p>添加字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 </span><br><span class="line">add [column] 字段名 数据类型 [约束] [comment 注释];</span><br></pre></td></tr></table></figure></li><li><p>添加索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 </span><br><span class="line">add [unique|fulltext|spatial] index 索引名称(字段名称[(长度)] [asc|desc]);</span><br></pre></td></tr></table></figure></li><li><p>添加 <code>check</code> 约束（域完整性）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名</span><br><span class="line">    add constraint 约束名称 check (条件);</span><br></pre></td></tr></table></figure></li><li><p>添加唯一约束（实体完整性）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 唯一约束</span><br><span class="line">alter table 表名</span><br><span class="line">    add constraint [约束名称（若不设置，则以字段名称作为约束名称）] unique (字段名称);</span><br></pre></td></tr></table></figure></li><li><p>添加主键约束和外键约束（参照完整性）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 主键约束</span><br><span class="line">alter table 表名</span><br><span class="line">add constraint [约束名称（在 MySql 即使设置该参数也会被忽略）] primary key (字段名称);</span><br><span class="line"></span><br><span class="line"># 外键约束</span><br><span class="line">alter table 表名</span><br><span class="line">    add constraint 约束名称 foreign key(字段名称)</span><br><span class="line">        references 被引用表名 (被引用字段名称);</span><br><span class="line"># 注意：必须先为被引用字段创建索引，通常是主键索引</span><br></pre></td></tr></table></figure></li><li><p>修改数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table </span><br><span class="line">modify 字段名 新数据类型 [约束] [comment 注释];</span><br></pre></td></tr></table></figure></li><li><p>修改字段名和数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table </span><br><span class="line">change 旧字段名 新字段名 新数据类型 [约束] [comment 注释];</span><br></pre></td></tr></table></figure></li><li><p>修改表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table 旧表名 rename to 新表名;</span><br><span class="line"># 或者</span><br><span class="line">rename table 旧表名 to 新表名;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4删除-drop-table-truncate-table-alter-table-drop-drop-index"><a class="markdownIt-Anchor" href="#4删除-drop-table-truncate-table-alter-table-drop-drop-index"></a> （4）删除 <code>drop table</code> | <code>truncate table</code> | <code>alter table drop</code>  | <code>drop index</code></h3><ul><li><p>删除表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table [if exists] 表名;</span><br></pre></td></tr></table></figure></li><li><p>删除，并重建指定表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate table 表名;</span><br></pre></td></tr></table></figure></li><li><p>删除字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 </span><br><span class="line">drop 字段名;</span><br></pre></td></tr></table></figure></li><li><p>删除约束</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名</span><br><span class="line">drop constraint 约束名;</span><br><span class="line"></span><br><span class="line"># 删除主键约束有三种写法，分别是：</span><br><span class="line">alter table 表名</span><br><span class="line">drop primary key;</span><br><span class="line"># 或者 (不推荐)</span><br><span class="line">alter table 表名</span><br><span class="line">drop constraint `primary`;</span><br><span class="line"># 或者 (不推荐)</span><br><span class="line">drop index `primary` on 表名;</span><br></pre></td></tr></table></figure></li><li><p>删除索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名</span><br><span class="line">drop index 索引名;</span><br><span class="line"># 或者</span><br><span class="line">drop index 索引名 on 表名;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5常用的数据类型"><a class="markdownIt-Anchor" href="#5常用的数据类型"></a> （5）常用的数据类型</h3><h4 id="1-数值类型"><a class="markdownIt-Anchor" href="#1-数值类型"></a> ① 数值类型</h4><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">大小</th><th style="text-align:center">范围（有符号）</th><th style="text-align:center">范围（无符号）</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center"><code>tinyint</code></td><td style="text-align:center">1 Bytes</td><td style="text-align:center">(-128，127)</td><td style="text-align:center">(0，255)</td><td style="text-align:center">小整数值</td></tr><tr><td style="text-align:center"><code>smallint</code></td><td style="text-align:center">2 Bytes</td><td style="text-align:center">(-32 768，32 767)</td><td style="text-align:center">(0，65 535)</td><td style="text-align:center">大整数值</td></tr><tr><td style="text-align:center"><code>mediumint</code></td><td style="text-align:center">3 Bytes</td><td style="text-align:center">(-8 388 608，8 388 607)</td><td style="text-align:center">(0，16 777 215)</td><td style="text-align:center">大整数值</td></tr><tr><td style="text-align:center"><code>int</code> <code>integer</code></td><td style="text-align:center">4 Bytes</td><td style="text-align:center">(-2 147 483 648，2 147 483 647)</td><td style="text-align:center">(0，4 294 967 295)</td><td style="text-align:center">大整数值</td></tr><tr><td style="text-align:center"><code>bigint</code></td><td style="text-align:center">8 Bytes</td><td style="text-align:center">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td style="text-align:center">(0，18 446 744 073 709 551 615)</td><td style="text-align:center">极大整数值</td></tr><tr><td style="text-align:center"><code>float</code></td><td style="text-align:center">4 Bytes</td><td style="text-align:center">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td style="text-align:center">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td style="text-align:center">单精度 浮点数值</td></tr><tr><td style="text-align:center"><code>double</code></td><td style="text-align:center">8 Bytes</td><td style="text-align:center">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td style="text-align:center">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td style="text-align:center">双精度 浮点数值</td></tr><tr><td style="text-align:center"><code>decimal</code></td><td style="text-align:center">对decimal(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td style="text-align:center">依赖于M和D的值</td><td style="text-align:center">依赖于M和D的值</td><td style="text-align:center">小数值</td></tr></tbody></table><h4 id="2-日期类型"><a class="markdownIt-Anchor" href="#2-日期类型"></a> ② 日期类型</h4><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">大小（Bytes）</th><th style="text-align:center">范围</th><th style="text-align:center">格式</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center"><code>date</code></td><td style="text-align:center">3</td><td style="text-align:center">1000-01-01/9999-12-31</td><td style="text-align:center">YYYY-MM-DD</td><td style="text-align:center">日期值</td></tr><tr><td style="text-align:center"><code>time</code></td><td style="text-align:center">3</td><td style="text-align:center">‘-838:59:59’/‘838:59:59’</td><td style="text-align:center">HH:MM:SS</td><td style="text-align:center">时间值或持续时间</td></tr><tr><td style="text-align:center"><code>year</code></td><td style="text-align:center">1</td><td style="text-align:center">1901/2155</td><td style="text-align:center">YYYY</td><td style="text-align:center">年份值</td></tr><tr><td style="text-align:center"><code>datatime</code></td><td style="text-align:center">8</td><td style="text-align:center">‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td><td style="text-align:center">YYYY-MM-DD hh:mm:ss</td><td style="text-align:center">混合日期和时间值</td></tr><tr><td style="text-align:center"><code>timestamp</code></td><td style="text-align:center">4</td><td style="text-align:center">‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td style="text-align:center">YYYY-MM-DD hh:mm:ss</td><td style="text-align:center">混合日期和时间值，时间戳</td></tr></tbody></table><h4 id="3-字符串类型"><a class="markdownIt-Anchor" href="#3-字符串类型"></a> ③ 字符串类型</h4><blockquote><p>char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</p></blockquote><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">大小</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center"><code>char</code></td><td style="text-align:center">0-255 bytes</td><td style="text-align:center">定长字符串</td></tr><tr><td style="text-align:center"><code>varchar</code></td><td style="text-align:center">0-65535 bytes</td><td style="text-align:center">变长字符串</td></tr><tr><td style="text-align:center"><code>tinyblob</code></td><td style="text-align:center">0-255 bytes</td><td style="text-align:center">不超过 255 个字符的二进制字符串</td></tr><tr><td style="text-align:center"><code>tinytext</code></td><td style="text-align:center">0-255 bytes</td><td style="text-align:center">短文本字符串</td></tr><tr><td style="text-align:center"><code>blob</code></td><td style="text-align:center">0-65 535 bytes</td><td style="text-align:center">二进制形式的长文本数据</td></tr><tr><td style="text-align:center"><code>text</code></td><td style="text-align:center">0-65 535 bytes</td><td style="text-align:center">长文本数据</td></tr><tr><td style="text-align:center"><code>mediumblob</code></td><td style="text-align:center">0-16 777 215 bytes</td><td style="text-align:center">二进制形式的中等长度文本数据</td></tr><tr><td style="text-align:center"><code>mdeiumtext</code></td><td style="text-align:center">0-16 777 215 bytes</td><td style="text-align:center">中等长度文本数据</td></tr><tr><td style="text-align:center"><code>longblob</code></td><td style="text-align:center">0-4 294 967 295 bytes</td><td style="text-align:center">二进制形式的极大文本数据</td></tr><tr><td style="text-align:center"><code>longtext</code></td><td style="text-align:center">0-4 294 967 295 bytes</td><td style="text-align:center">极大文本数据</td></tr></tbody></table><h2 id="3-视图操作"><a class="markdownIt-Anchor" href="#3-视图操作"></a> 3.  视图操作</h2><h1 id="二-dml"><a class="markdownIt-Anchor" href="#二-dml"></a> 二、DML</h1><h1 id="三-dql"><a class="markdownIt-Anchor" href="#三-dql"></a> 三、 DQL</h1><h1 id="四-dcl"><a class="markdownIt-Anchor" href="#四-dcl"></a> 四、 DCL</h1>]]></content>
      
      
      
        <tags>
            
            <tag> MySql </tag>
            
            <tag> Sql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可解释机器学习 —— LIME 篇</title>
      <link href="/posts/1.html"/>
      <url>/posts/1.html</url>
      
        <content type="html"><![CDATA[<h2 id="一-什么是解释"><a class="markdownIt-Anchor" href="#一-什么是解释"></a> 一、什么是解释？</h2><p>所谓解释，指的是使用我们能够理解的方法（如图像、文本、简化的模型等）来揭示输入数据的特定部分（例如文本中的词语、图像中的像素）与模型做出特定预测之间的关系。这种解释帮助我们定性地理解模型的工作原理和决策过程，尤其是对于那些复杂且通常被视为“黑盒”的模型。简而言之，解释旨在建立模型输入与输出之间的直观联系，使得模型的行为对于人类用户更加透明和可理解。</p><h2 id="二-我们为什么需要解释"><a class="markdownIt-Anchor" href="#二-我们为什么需要解释"></a> 二、我们为什么需要解释？</h2><ol><li>决定是否该信任某个模型/预测</li><li>在不同模型之间做出选择</li><li>通过特征工程改进模型</li><li>确定某个模型为什么不可信</li></ol><blockquote><p>由此可以很容易知道解释在机器学习领域的重要性，但现如今所使用的很多机器学习模型尽管有着不错的性能，然而在解释性方面却是不足的。在机器学习模型的很多应用中，我们有时候必须要知道模型为什么做出这个预测，以及这个预测是否合理，而LIME正是为解决这个问题而诞生的算法。</p></blockquote><h2 id="三-相关论文"><a class="markdownIt-Anchor" href="#三-相关论文"></a> 三、相关论文</h2><p><a href="https://dl.acm.org/doi/abs/10.1145/2939672.2939778"><em>LIME:</em> Ribeiro, Marco Tulio, Sameer Singh, and Carlos Guestrin. “Why should i trust you?: Explaining the predictions of any classifier.” Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining. ACM, 2016.</a></p><p><em><strong>论文的主要成果：</strong></em></p><p><em>We propose providing explanations for individual predictions as a solution to the “trusting a prediction” problem, and selecting multiple such predictions (and explanations) as a solution to the “trusting the model” problem.</em></p><p><em>We proposed LIME, a modular and extensible approach to faithfully explain the predictions of any model in an interpretable manner. We also introduced SP-LIME, a method to select representative and non-redundant predictions, providing a global view of the model to users.</em></p><p><em><strong>代码仓库：</strong></em> <a href="https://github.com/marcotcr/lime">Lime: Explaining the predictions of any machine learning classifier - marcotcr/lime</a></p><h2 id="四-lime算法"><a class="markdownIt-Anchor" href="#四-lime算法"></a> 四、LIME算法</h2><h3 id="1-介绍"><a class="markdownIt-Anchor" href="#1-介绍"></a> 1. 介绍</h3><p><strong>LIME</strong>（即Local Interpretable Model-Agnostic Explanations）是一种局部解释的算法，它旨在为分类器或回归器的预测提供解释。通过使用“可解释特征”训练“可解释模型”，在“样本的局部线性邻域”拟合“原模型”，从而实现对复杂模型预测的解释。这种方法有助于增加模型的透明度和可信度，尤其是在需要解释预测以获得用户信任的情况下。</p><blockquote><p>LIME属于事后解释方法，具有局部性、可解释性、与模型无关性的特征。</p></blockquote><h3 id="2-原理"><a class="markdownIt-Anchor" href="#2-原理"></a> 2. 原理</h3><p>如下图所示，LIME首先在待解释样本点周围进行扰动采样，并按照扰动样本与原样本之间的相似度或距离赋予样本权重，然后用原模型对这些样本进行预测而获得标签值，并使用这些局部样本训练一个可解释性比较强的线性模型，这样就可以利用线性模型的可解释性对复杂模型进行局部解释。</p><p><img src="https://api.aspark.cc/image/202403172154071.png" alt="" /></p><p>算法使用目标函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ξ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi><munder><mo><mi>a</mi><mi>r</mi><mi>g</mi><mi>m</mi><mi>i</mi><mi>n</mi></mo><mrow><mi>g</mi><mo>∈</mo><mi>G</mi></mrow></munder></mi><mtext> </mtext><mi>L</mi><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><mi>g</mi><mo separator="true">,</mo><msub><mi>π</mi><mi>x</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\xi(x) = \underset{g \in G}{argmin}\ L(f, g, \pi_{x}) + \Omega(g)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.04601em;">ξ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.824879em;vertical-align:-1.074879em;"></span><span class="mord"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6595200000000001em;"><span style="top:-2.161229em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="mrel mtight">∈</span><span class="mord mathnormal mtight">G</span></span></span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop"><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.074879em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathnormal">L</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mclose">)</span></span></span></span> 衡量两个模型之间的差异。</p><h3 id="3-优点"><a class="markdownIt-Anchor" href="#3-优点"></a> 3. 优点</h3><ul><li>模型无关性（通用性强）：LIME能够兼容任何一种机器学习算法，具有广泛的适用性</li><li>可解释单个样本预测结果、选取代表性样本</li><li>LIME是少数适用于表格数据、文本和图像的方法之一</li></ul><h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3><ul><li>局部保真度不意味着全局保真度：在全局上重要的特征在局部上可能并不重要，反之亦然。</li><li>原模型如果在局部仍然非线性，可解释模型难以拟合原模型</li><li>时间成本高：每个待测样本都需训练对应可解释模型，耗时长</li><li>通过扰动得到的样本符合高斯分布，却忽略了特征之间的关系</li></ul><h3 id="4-实例"><a class="markdownIt-Anchor" href="#4-实例"></a> 4. 实例</h3><p>使用20newsgroups数据集中的alt.atheism和soc.religion.christianlian训练一个RFC模型，并且使用LIME对单个样本进行解释</p><ul><li>对选定的单个样本进行解释，结果如下：（样本的目标值为atheism）</li></ul><p><img src="https://api.aspark.cc/image/202403172154632.png" alt="" /></p><ul><li>将上述样本中的headers、footers、quotes移除后，再对该样本进行解释，结果如下：</li></ul><p><img src="https://api.aspark.cc/image/202403172155176.png" alt="" /></p><p>通过LIME我们可以很容易看出模型模型做出一个预测依赖于哪些特征，以及根据这些特征特征做出的预测是否合理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 可解释机器学习 </tag>
            
            <tag> LIME </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
